import { Injectable } from '@nestjs/common';
import { <%= name.pascalCase %>RepositoryModel } from '../models/<%= name.kebabCase %>-repository.model';
import { <%= name.pascalCase %>sModel } from '../models/<%= name.kebabCase %>s.model';
import { <%= name.pascalCase %>Model, <%= name.pascalCase %>Properties } from '../models/<%= name.kebabCase %>.model';
import { FindAllDto } from '@src/common/dto/find-all.dto';
import { Create<%= name.pascalCase %>Dto } from '../dto/create-<%= name.kebabCase %>.dto';
import { CrudMockMethods } from '@src/common/mocks/crud-mock.methods';
import { <%= name.pascalCase %>s } from '../entities/<%= name.kebabCase %>s';
import { Update<%= name.pascalCase %>Dto } from '../dto/update-<%= name.kebabCase %>.dto';
import { DeepPartial } from '@src/common/interfaces/deep-partial';
import { ResponseWithPaginate } from '@src/common/interfaces/response-with-paginate';
import { HelperMockMethods } from '@src/common/interfaces/helper-mock.methods';
import { <%= name.pascalCase %> } from '../entities/<%= name.kebabCase %>';

@Injectable()
export class <%= name.pascalCase %>LocalRepository implements <%= name.pascalCase %>RepositoryModel, HelperMockMethods<<%= name.pascalCase %>Model> {
  private <%= name.camelCase %>Crud: CrudMockMethods<<%= name.pascalCase %>Model>;

  constructor() {
    this.<%= name.camelCase %>Crud = new CrudMockMethods();
  }
  
  __changeStore(store: <%= name.pascalCase %>Model[]): void {
    this.<%= name.camelCase %>Crud.__changeStore(store);
  }

  __reset(): void {
    this.<%= name.camelCase %>Crud.__reset();
  }

  __setIsError(value: boolean): void {
    this.<%= name.camelCase %>Crud.__setIsError(value);
  }

  __getStore(): <%= name.pascalCase %>Model[] {
    return this.__getStore();
  }

  __isError(): boolean {
    return this.__isError();
  }

  async findOne(filter: DeepPartial<<%= name.pascalCase %>Properties>): Promise<<%= name.pascalCase %>Model | null> {
    const <%= name.camelCase %> = this.<%= name.camelCase %>Crud.findOne(filter);
    return Promise.resolve(<%= name.camelCase %>);
  }

  async findAll(
    filter: DeepPartial<<%= name.pascalCase %>Properties>,
    options: FindAllDto,
  ): Promise<ResponseWithPaginate<<%= name.pascalCase %>sModel>> {
    //using options
    options;
    //code
    const <%= name.camelCase %>s = this.<%= name.camelCase %>Crud.findAll(filter);
    return Promise.resolve({
      entities: new <%= name.pascalCase %>s(<%= name.camelCase %>s),
      totalElement: 1,
      totalPage: 1,
    });
  }

  async create(options: Create<%= name.pascalCase %>Dto): Promise<<%= name.pascalCase %>Model> {
    const <%= name.camelCase %> = new <%= name.pascalCase %>(options);
    return this.<%= name.camelCase %>Crud.create(<%= name.camelCase %>);
  }

  async updateOne(
    filter: DeepPartial<<%= name.pascalCase %>Properties>,
    options: Update<%= name.pascalCase %>Dto,
  ): Promise<<%= name.pascalCase %>Model> {
    return this.<%= name.camelCase %>Crud.update(filter, options);
  }

  async removeOne(filter: DeepPartial<<%= name.pascalCase %>Properties>): Promise<<%= name.pascalCase %>Model> {
    return this.<%= name.camelCase %>Crud.delete(filter);
  }

  async updateMany(
    filter: DeepPartial<<%= name.pascalCase %>Properties>,
    options: Update<%= name.pascalCase %>Dto,
  ): Promise<boolean> {
    return this.<%= name.camelCase %>Crud.updateMany(filter, options);
  }

  async removeMany(filter: DeepPartial<<%= name.pascalCase %>Properties>): Promise<boolean> {
    return this.<%= name.camelCase %>Crud.deleteMany(filter);
  }
}
